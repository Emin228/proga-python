## ***Лабораторная работ №5***
## **Постановка задачи:** 
Изучить материал про мемоизацию и реализовать сравнение мемоизованных и немемоизованных вариантов функций (рекурсивной и нерекурсивной. Проанализировать результаты и сделать выводы, описать выводы в отчете, построить графики.
## **Список идентификаторов:**
| Имя                         | Тип               | Смысл                                                                       |
| --------------------------- | ----------------- | --------------------------------------------------------------------------- |
| `timeit`                    | модуль            | Стандартный модуль Python для измерения времени выполнения кода             |
| `matplotlib.pyplot` / `plt` | модуль            | Модуль для визуализации графиков                                            |
| `random`                    | модуль            | Стандартный модуль Python для генерации случайных чисел                     |
| `lru_cache`                 | декоратор         | Декоратор из `functools` для кеширования результатов функций                |
| `dsd.lru`                   | функция/декоратор | Пользовательская функция LRU-кеша (по твоему импорту `from dsd import lru`) |
| `fact_recursive`            | функция           | Рекурсивная реализация факториала                                           |
| `fact_iterative`            | функция           | Итеративная реализация факториала с кешированием `@lru_cache`               |
| `benchmark`                 | функция           | Функция для измерения среднего времени выполнения переданной функции `func` |
| `func`                      | параметр функции  | Функция, которую нужно замерять                                             |
| `n`                         | параметр функции  | Аргумент функции факториала                                                 |
| `number`                    | параметр функции  | Количество вызовов функции за один замер времени                            |
| `repeat`                    | параметр функции  | Сколько раз повторять замер времени и выбирать минимальное                  |
| `times`                     | список            | Список времен выполнения функции для каждого повторения                     |
| `main`                      | функция           | Главная функция скрипта, запускает бенчмарки и строит график                |
| `test_data`                 | список            | Список чисел `n`, для которых вычисляется факториал                         |
| `res_recursive`             | список            | Время выполнения рекурсивного факториала для каждого `n`                    |
| `res_iterative`             | список            | Время выполнения итеративного факториала для каждого `n`                    |
| lru                         | Декоратор         |                                                                             |

## **Код:**

**Код для построения графиков и вычисления времени выполнения:**
```python
import timeit
import matplotlib.pyplot as plt
import random
from functools import lru_cache
from lruEmin import lru

@lru
def fact_recursive(n: int) -> int:
    """Рекурсивный факториал"""
    if n == 0:
        return 1
    return n * fact_recursive(n - 1)

@lru_cache
def fact_iterative(n: int) -> int:
    """Нерекурсивный факториал"""
    res = 1
    for i in range(1, n + 1):
        res *= i
    return res
    
def benchmark(func, n, number=1, repeat=5):
    """Возвращает среднее время выполнения func(n)"""
    times = timeit.repeat(lambda: func(n), number=number, repeat=repeat)
    return min(times)

def main():
    # фиксированный набор данных
    random.seed(42)
    test_data = list(range(10, 300, 10))
    res_recursive = []
    res_iterative = []
    
    for n in test_data:
      res_recursive.append(benchmark(fact_recursive, n, repeat=5, number=1000))
      res_iterative.append(benchmark(fact_iterative, n, repeat=5, number=1000))
    print(res_recursive, res_iterative)

    # Визуализация
    plt.plot(test_data, res_recursive, label="Рекурсивный")
    plt.plot(test_data, res_iterative, label="Итеративный")
    plt.xlabel("n")
    plt.ylabel("Время (сек)")
    plt.title("Сравнение рекурсивного и итеративного факториала")
    plt.legend()
    plt.show()

  
if __name__ == "__main__":
    main()
```

**Код декоратора:**

```python
def lru(func):
    cache = {}  
    max_size = 5  

    def wrapper(n):
        if n in cache:
            return cache[n]  
        result = func(n)  
        cache[n] = result
        if len(cache) > max_size:
            del cache[next(iter(cache))]
        return result
        
    return wrapper
```
### **1.** Рекурсивый и итеративный

### **2.** Рекурсивный(lru_cache) и рекурсивный



### **3.** Рекурсивный(lru_cache) и итеративный

### **4.** Итеративный(lru_cache) и итеративный



### 5.  lru и lru_cache
## **Вывод**