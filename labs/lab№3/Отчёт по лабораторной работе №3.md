# *Лабораторная работа №3. Построение бинарного дерева(рекурсивным методом)*
## **Постановка задачи:**

Разработайте программу на языке Python, которая будет строить **бинарное дерево** (_дерево, в каждом узле которого может быть только два потомка_). Отображение результата в виде словаря (как базовый вариант решения задания). Далее исследовать другие структуры, в том числе доступные в модуле collections в качестве контейнеров для хранения структуры бинарного дерева.

## **Список идентификаторов:**


| Имя          | Тип      | Смысл                                                                   |
| ------------ | -------- | ----------------------------------------------------------------------- |
| gen_bin_tree | function | Функция реализующая построения бинарного дерева                         |
| heigth       | int      | Заданная высота бинарного дерева                                        |
| Root         | int      | Число находящееся в корне дерева                                        |
| left_child   | dict     | Результат рекурсивного вызова функции для левого поддерева (root + 1).  |
| rigth_child  | dict     | Результат рекурсивного вызова функции для правого поддерева (root - 1). |
| value        | str      | Ключ в словаре, содержащий значение узла дерева.                        |
| left         | str      | Ключ в словаре, указывающий на левое поддерево или None                 |
| rigth        | str      | Ключ в словаре, указывающий на правое поддерево или None                |


## **Код функции:**

```python
from pprint import pprint
from typing import Callable

"""Подключение библиотеки pprint для более коректного вывода результата"""
def gen_bin_tree(height=2, Root=0,
                left_leaf:Callable[[float], float] = lambda x: x -1,
                right_leaf:Callable[[float], float] = lambda y: y + 1):


    """
    Рекурсивно генерирует бинарное дерево заданной высоты.
    Каждый узел дерева представлен в виде словаря с ключами:
    - "value": значение текущего узла;
    - "left": левое поддерево (или None, если достигнут лист);
    - "right": правое поддерево (или None, если достигнут лист).

    При каждой рекурсии значение левого потомка увеличивается на 1,
    а правого уменьшается на 1 относительно значения родительского узла.

    Returns:
    dict
        Словарь, описывающий структуру бинарного дерева.
    """

    height = int(height)
    Root = int(Root)
    
    if int(height) == 0:
        return {"value": Root, "left": None, "right": None}
    """Проверка, что значение узла не равно 0, для корректной работы """
    left_child = left_leaf(Root)
    right_child = right_leaf(Root)
    """
    Расчёт правого и левого поддерева
    """
    return {
        "value": Root,
        "left": gen_bin_tree(height-1,left_child, left_leaf, right_leaf),
        "right": gen_bin_tree(height-1, right_child, left_leaf, right_leaf)
    }
```

## **Результат**
```python
{'left': {'left': {'left': {'left': None, 'right': None, 'value': 10},
                   'right': {'left': None, 'right': None, 'value': 12},
                   'value': 11},
          'right': {'left': {'left': None, 'right': None, 'value': 12},     
                    'right': {'left': None, 'right': None, 'value': 14},    
                    'value': 13},
          'value': 12},
 'right': {'left': {'left': {'left': None, 'right': None, 'value': 12},     
                    'right': {'left': None, 'right': None, 'value': 14},    
                    'value': 13},
           'right': {'left': {'left': None, 'right': None, 'value': 14},    
                     'right': {'left': None, 'right': None, 'value': 16},   
                     'value': 15},
           'value': 14},
 'value': 13}
```
Для более удобного вывода, была использована импортированная фукнция pprint
```python
from pprint import pprint
```

Также были проведены 3 теста, для проверки работы функции, с котрыми можете ознакоится [здесь](https://github.com/Emin228/proga-python/blob/main/labs/lab№3/test_laba3.py)


## **Вывод**

В ходе лабораторной работы, было выполнено построение бинарного дерева при помощи реализации рекурсивной функции. Алгоритм построения дерева учитывал параметры заранее заданные лично для каждого студента. Результат построения отобразили в виде словаря, а для вывода результата использовали фукнцию pprint. Работа послужила как хоршоей практикой для работы со структурами, так и для лучшего понимания рекурсивной функции
